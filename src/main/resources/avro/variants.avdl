@namespace("org.ga4gh.models")
protocol Variants {

import idl "common.avdl";
import idl "metadata.avdl";
 
/**
This metadata represents VCF header information.
*/
record VariantSetMetadata {
  /** The top-level key. */
  string key;

  /** The value field for simple metadata. */
  string value;

  /**
  User-provided ID field, not enforced by this API.
  Two or more pieces of structured metadata with identical
  id and key fields are considered equivalent.
  */
  string id;

  /** The type of data. */
  string type;

  /**
  The number of values that can be included in a field described by this
  metadata.
  */
  string number;

  /** A textual description of this metadata. */
  string description;

  /** Remaining structured metadata key-value pairs. */
  map<array<string>> info = {};
}

/**
`Variant` and `CallSet` both belong to a `VariantSet`.
`VariantSet` belongs to a `Dataset`.
The variant set is equivalent to a VCF file.
*/
record VariantSet {
  /** The variant set ID. */
  string id;

  /** The ID of the dataset this variant set belongs to. */
  string datasetId;

  /**
  The reference set the variants in this variant set are using.
  */
  string referenceSetId;

  /**
  The metadata associated with this variant set. This is equivalent to
  the VCF header information not already presented in first class fields.
  */
  array<VariantSetMetadata> metadata = [];
}

/**
A `CallSet` is a collection of variant calls for a particular sample.
It belongs to a `VariantSet`. This is equivalent to one column in VCF.
*/
record CallSet {

  /** The call set ID. */
  string id;

  /** The call set name. */
  union { null, string } name = null;

  /** The sample this call set's data was generated from. */
  union { null, string } sampleId;

  /** The IDs of the variant sets this call set has calls in. */
  array<string> variantSetIds = [];

  /** The date this call set was created in milliseconds from the epoch. */
  union { null, long } created = null;

  /**
  The time at which this call set was last updated in
  milliseconds from the epoch.
  */
  union { null, long } updated = null;

  /**
  A map of additional call set information.
  */
  map<array<string>> info = {};
}

/**
A `Call` represents the determination of genotype with respect to a
particular variant. It may include associated information such as quality
and phasing. For example, a call might assign a probability of 0.32 to
the occurrence of a SNP named rs1234 in a call set with the name NA12345.
*/
record Call {

  /**
  The ID of the call set this variant call belongs to.
  If this field is not present, the ordering of the call sets from a
  `SearchCallSetsRequest` over this `VariantSet` is guaranteed to match
  the ordering of the calls on this `Variant`.
  The number of results will also be the same.
  */
  union { null, string } callSetId;

  /**
  The name of the call set this variant call belongs to.
  If this field is not present, the ordering of the call sets from a
  `SearchCallSetsRequest` over this `VariantSet` is guaranteed to match
  the ordering of the calls on this `Variant`.
  The number of results will also be the same.
  */
  union { null, string } callSetName = null;

  /**
  The genotype of this variant call. Each value represents either the value
  of the referenceBases field or is a 1-based index into alternateBases.
  If a variant had a referenceBases field of "T", an alternateBases
  value of ["A", "C"], and the genotype was [2, 1], that would mean the call
  represented the heterozygous value "CA" for this variant. If the genotype
  was instead [0, 1] the represented value would be "TA". Ordering of the
  genotype values is important if the phaseset field is present.
  */
  array<int> genotype = [];

  /**
  If this field is present, this variant call's genotype ordering implies
  the phase of the bases and is consistent with any other variant calls on
  the same contig which have the same phaseset value.
  */
  union { null, string } phaseset = null;

  /**
  The genotype likelihoods for this variant call. Each array entry
  represents how likely a specific genotype is for this call as
  log10(P(data | genotype)), analogous to the GL tag in the VCF spec. The
  value ordering is defined by the GL tag in the VCF spec.
  */
  array<double> genotypeLikelihood = [];

  /**
  A map of additional variant call information.
  */
  map<array<string>> info = {};
}

/** TODO: Add more regulatory features. 
          Move to common or annotation?
*/
enum GenomicFeatureType {
  TRANSCRIPT, 
  EXON,
  INTRON,
  MICRO_RNA, 
  REGULATORY_ELEMENT, 
  MOTIF
}

/**
An AnalysisResult record the output of a prediction package such as Sift
on a specific allele 
*/
record AnalysisResult {

  /** Alternate allele - variant may have >1 alt which will have distinct 
  analysis results. This is not be needed for the graph/allele model 
  */
  union { null, string} alternateBase = null;

  /** The analysis record for this result (defined in metadata schema)
  */
  Analysis analysis;

  /** The text-based result for this analysis
  */
  union { null, string} analysisResult;

  /** The numeric score for this analysis 
  */
  union { null, float} analysisScore;
}

/**
  Impact is a simple prioritization for Annotation.

  IMPORTANT:
    Prioritization methods are a crude estimates and are not assumed to be
    reliable: e.g a 'HIGH' Impact may actually not cause any disruption
    in protein function or expression.
*/
enum Impact {
  HIGH,      // Variant highly disrupts protein function
  MODERATE,  // Moderately disrupts protein function
  LOW,       // Low disruption of protein impact
  MODIFIER   // No known effect
}

/**
An annotation record is a set of information describing the effect of an
allele on another genomic feature

To do (all these can be easily added after the PR has been accepted): 
  1) Make sure transctipt records contain:
    - Biotype (according to HAVANA types)
    - cdnaLength
    - cdsLength
    - proteinLength
    - tls (Transcript Level Support) or 'isCanonical'

  2) Split into coding and non-coding records
  3) Clinical impact 
  4) Consistency with HGVS: Do we require annotating the "most 3Â­prime
     coordinate" as HGVS does? 
       i) If we do, then variant coordinates and annotation coordinates may 
          not match (we should inform the 'new coordinates' somewhere).

       ii) If we don't, then variant annotation may not match HGVS.p 
           anntation, which is extremelly confusing.

Comments: 
  1) We may want to annotate respect to specific exon 
     (i.e. featureId = exonId instead of transcriptId) in order to know 
     more detailed information (exon rank, exon splice type, etc.)
  2) Effects sort order: People prefer to see 'most deleterious' / 'most 
     important transcripts' first. Should we add this here or should it 
     be left for the 'presentation' layer?. It doesn't hurt to suggest 
     an order...
  3) Gene name has to be retrieve via: Exon -> Transcript -> Gene. It might 
     be too indirect for common queries (e.g. get all high impact varints 
     in 'BRAC1')
*/
record Annotation {

  /** The feature ID. Links to sequence annotation record
  */
  string featureId;

  /** The feature type
  */
  GenomicFeatureType genomicFeatureType;

  /** Effect of variant on this feature (Sequence Ontology term)
  */
  array<OntologyTerm> effects;

  /** Putative impact for each effect
  */
  array<Impact> impacts;

  /** HGVS formatted annotation at genomic, transcript and protein level
  */
  union { null, string } HGVSg = null;
  union { null, string } HGVSc = null;
  union { null, string } HGVSp = null;
  
  /** Location information
  */

  /** Relative position of base in cDNA sequence 
      Note: The coresponding cdnaLength field should be available 
            in transcript's record
  */
  union { null, int} cdnaPosition = null; 

  /** Relative position of base in coding sequence  
      Note: The coresponding cdsLength field should be available 
            in transcript's record
  */
  union { null, int} cdsPosition = null; 

  /** Relative position of amino acid in protein  
      Note: The coresponding proteinLength field should be available 
            in transcript's record
  */
  union { null, int} proteinPosition = null; 

  /** Reference/Alt allele information
  */

  /** Alternate allele - variant may have >1 alt which will have distinct 
  annotation. This is not be needed for the graph/allele model 
  */
  union { null, string} alternateBases = null;
 
  /**
    Genotype reference.
    This is used when a reference (different than the standard reference genome)
    is used to calculate the effects, typically for cancer samples when
    germline and somatic differ from reference genome. Since we are interested
    in somatic effect respect to germline, germinle variant acts as reference 
	(instead of using  the reference genome).
  */
  union {null, string} referenceBases = null;

  /** Reference Amino Acid
  */
  union { null, string } referenceAminoAcid = null;

  /** Alternate Amino Acid
  */
  union { null, string } alternateAminoAcid  = null;

  /** Codon observed in reference 
  */
  union { null, string } referenceCodon = null;

  /** Codon created by alt alternate allele
  */
  union { null, string } alternateCodon = null;

  /** Output from prediction packages such as Sift
  */
  array<AnalysisResult> analysisResults;
}

/**
A `Variant` represents a change in DNA sequence relative to some reference.
For example, a variant could represent a SNP or an insertion.
Variants belong to a `VariantSet`.
This is equivalent to a row in VCF.
*/
record Variant {

  /** The variant ID. */
  string id;

  /** The ID of the variant set this variant belongs to. */
  string variantSetId;

  /** Names for the variant, for example a RefSNP ID. */
  array<string> names = [];

  /** The date this variant was created in milliseconds from the epoch. */
  union { null, long } created = null;

  /**
  The time at which this variant was last updated in
  milliseconds from the epoch.
  */
  union { null, long } updated = null;

  /**
  The reference on which this variant occurs.
  (e.g. `chr20` or `X`)
  */
  string referenceName;

  /**
  The start position at which this variant occurs (0-based).
  This corresponds to the first base of the string of reference bases.
  Genomic positions are non-negative integers less than reference length.
  Variants spanning the join of circular genomes are represented as
  two variants one on each side of the join (position 0).
  */
  long start;

  /**
  The end position (exclusive), resulting in [start, end) closed-open interval.
  This is typically calculated by `start + referenceBases.length`.
  */
  long end;

  /** The reference bases for this variant. They start at the given position. */
  string referenceBases;

  /** The bases that appear instead of the reference bases. */
  array<string> alternateBases = [];

  /**
  A map of additional variant information.
  */
  map<array<string>> info = {};

  /**
  The variant calls for this particular variant. Each one represents the
  determination of genotype with respect to this variant.
  */
  array<Call> calls = [];

  /**
  The annotation for this particular allele/variant. Each one represents
  effect of an allele on a genomic feature (eg a transcript).
  */
  array<Annotation> annotation = [];
}

}
